var allPages = {
	config: {},
	cachedEvent: '',
	
	/**
	 *  Functions in this object are iterated over & executed on every page.
	 */
	
	commonFunctions: {
		error_check: function() {
			if (document.body.style.backgroundImage.indexOf('errorlinks.png') > -1) {
				var dialog = document.createElement('dialog');
				dialog.style.border = '1px solid rgba(0, 0, 0, 0.3)';
				dialog.style.borderRadius = '6px';
				dialog.style.boxShadow = '0 3px 7px rgba(0, 0, 0, 0.3)';
				
				dialog.style.backgroundImage = "url('" + browser.extension.getURL('/src/images/popup.png') + "')";
				dialog.style.backgroundColor = 'white';
				dialog.style.backgroundRepeat = 'no-repeat';
				dialog.style.backgroundPosition = 'center bottom';
				
				dialog.innerHTML = 'Error detected... redirect to history.php?' + '<br>'
						+ '(popup generated by ChromeLL)' + '<br>' + '<br>';
				
				var redirect = document.createElement('button');				
				redirect.innerText = 'Redirect';
				
				redirect.addEventListener('click', () => {
					window.location.href = window.location.protocol + '//boards.endoftheinter.net/history.php?b';
				});
				
				var close = document.createElement('button');
				close.innerText = 'Close';
				
				close.addEventListener('click', () => {
					dialog.close();
				});
				
				document.body.style.overflow = "hidden";
				
				dialog.appendChild(redirect);
				dialog.appendChild(close);
				document.body.appendChild(dialog);
				
				// Firefox doesn't support dialog methods such as show(), showModal(), etc so we need a polyfill
				dialogPolyfill.registerDialog(dialog);
				
				dialog.showModal();
				
				// Stop execution
				allPages.commonFunctions = {};
			}
		},
		
		notify_pm : function() {
			var userbar_pms = document.getElementById('userbar_pms');
			
			if (!userbar_pms) {
				return;
			}

			// Check for mutations to userbar_pms element, so we can get current number of unread PMs
			
			var observer = new MutationObserver(() => {
				
				if (userbar_pms.style.display == 'none' && allPages.config.pms !== 0) {
					// clear unread message count from config
					allPages.config.pms = 0;
					browser.runtime.sendMessage({
							need : "save",
							name : "pms",
							data : allPages.config.pms
					});
				}
				
				else if (userbar_pms.style.display != 'none') {
					var pms_text = userbar_pms.innerText;
					var pm_number = parseInt(pms_text.match(/\((\d+)\)/)[1]);
					var notify_title, notify_msg;
					// compare pm_number to last known value for pm_number
					if (pm_number > allPages.config.pms) {
						// you have mail
						if (pm_number === 1) {
							notify_title = 'New PM';
							notify_msg = 'You have 1 unread private message.';
						}
						else {
							notify_title = 'New PMs';
							notify_msg = 'You have ' + pm_number
									+ ' unread private messages.';
						}
						
						// notify user and save current pm_number
						browser.runtime.sendMessage({
								need: "notify",
								title: notify_title,
								message: notify_msg
						});
						
						allPages.config.pms = pm_number;
						
						browser.runtime.sendMessage({
								need : "save",
								name : "pms",
								data : allPages.config.pms
						});
					}
					else {
						// user has unread PMs, but no new PMs
						return;
					}
				}
			});
			
			observer.observe(userbar_pms, {
					attributes: true,
					childList: true
			});
		},
		
		history_menubar : function() {
			var link = document.createElement('a');
			link.innerHTML = 'Message History';
			if (allPages.config.history_menubar_classic)
				link.href = '//boards.endoftheinter.net/history.php';
			else
				link.href = '//boards.endoftheinter.net/topics/Posted';
			if (document.body.className === 'regular') {
				var sep = document.createElement('span');
				var menubar = document.getElementsByClassName('menubar')[0];
				sep.innerHTML = ' | ';
				menubar.insertBefore(link, menubar.getElementsByTagName('br')[0]);
				menubar.insertBefore(sep, link);
			} else if (document.body.className === 'classic') {
				var br = document.createElement('br');
				document.getElementsByClassName('classic3')[0].insertBefore(link,
						null);
				document.getElementsByClassName('classic3')[0].insertBefore(br,
						link);
			}
		},
		
		float_userbar : function() {
			var id = document.createElement('div');
			var userbar = document.getElementsByClassName('userbar')[0];
			var menubar = document.getElementsByClassName('menubar')[0];
			document.getElementsByClassName('body')[0].removeChild(userbar);
			document.getElementsByClassName('body')[0].removeChild(menubar);
			id.insertBefore(menubar, null);
			id.insertBefore(userbar, null);
			id.style.position = 'fixed';
			id.style.width = '100%';
			id.style.top = '0';
			userbar.style.marginTop = '-2px';
			userbar.style.borderBottomLeftRadius = '5px';
			userbar.style.borderBottomRightRadius = '5px';
			allPages.config.remove_links ? document.getElementsByTagName('h1')[0].style.paddingTop = '20px'
					: document.getElementsByTagName('h1')[0].style.paddingTop = '40px';
			document.getElementsByClassName('body')[0].insertBefore(id, null);
		},
		
		float_userbar_bottom : function() {
			var menubar = document.getElementsByClassName('menubar')[0];
			var userbar = document.getElementsByClassName('userbar')[0];
			menubar.style.position = "fixed";
			menubar.style.width = "99%";
			menubar.style.bottom = "-2px";
			userbar.style.position = "fixed";
			userbar.style.borderTopLeftRadius = '5px';
			userbar.style.borderTopRightRadius = '5px';
			userbar.style.width = "99%";
			userbar.style.bottom = "33px";
			menubar.style.marginRight = "20px";
			menubar.style.zIndex = '2';
			userbar.style.zIndex = '2';
		},
		
		short_title : function() {
			document.title = document.title.replace(/End of the Internet - /i, '');
		},
		
		user_info_popup : function() {		
			// Create placeholder popup that we can populate later.
			var links = ["PM", "GT", "BT", "HIGHLIGHT", "UNHIGHLIGHT", "IGNORATE"];					
			var popupElement = document.createElement('div');			
			popupElement.className = 'user_info_popup';
			popupElement.id = 'user-popup-div';
			var info = document.createElement('div');
			info.className = 'user_info_popup';
			info.id = 'popup_info';
			var user = document.createElement('div');
			user.className = 'user_info_popup';
			user.id = 'popup_user';

			for (var i = 0, len = links.length; i < len; i++) {
				var span = document.createElement('span');
				span.className = 'popup_link';
				span.innerHTML = links[i];
				span.addEventListener('click', allPages.userInfoPopup.clickHandler);
				info.appendChild(span);
			}
			
			info.style.display = 'none';
			
			popupElement.appendChild(user);
			popupElement.appendChild(info);
			document.body.appendChild(popupElement);				
			
			document.addEventListener('click', (evt) => {
				if (evt.target.className != 'popup_link') {
					allPages.userInfoPopup.hide();
				}
			});
		}
	},
	
	/**
	 *  Methods which create user info popup and populate it with info from user's profile page.
	 */
	
	userInfoPopup: {
		
		handler: function() {
			// Use cached event as this method is called from setTimeout
			var evt = allPages.cachedEvent;			
			var usernameAnchor = evt.target;
			
			var boundingRect = usernameAnchor.getBoundingClientRect();
			var x = (boundingRect.left + (boundingRect.width / 2)) - document.body.scrollLeft + usernameAnchor.clientLeft;
			var y = boundingRect.top + document.body.scrollTop + usernameAnchor.clientTop;
			
			var profileURL = usernameAnchor.href;
			this.username = usernameAnchor.innerHTML;
			this.currentPost = usernameAnchor.parentNode;			
			this.userId = profileURL.match(/user=(\d+)/)[1];
			
			var gs = this.checkAccountAge(this.userId);
			
			var xhr = new XMLHttpRequest();
			xhr.open("GET", profileURL, true);			
			xhr.onload = function() {
				if (this.status == 200) {
					allPages.userInfoPopup.scrapeProfile(this.responseText);
				}
			};		
			xhr.send();
			
			var popup = document.getElementById('popup_user');

			popup.innerHTML = '<div id="username" class="user_info_popup">' + this.username + " " + gs 
					+ ' <span id="popup_uid" class="user_info_popup">' + this.userId + '</span></div>'					
					+ '<div id="namechange" class="user_info_popup"></div>'					
					+ '<div id="rep" class="user_info_popup"><span id="popup_loading" class="user_info_popup">loading...</span></div>'
					+ '<div id="online" class="user_info_popup"></div>' 
					+ '<div id="punish" class="user_info_popup"></div>';
					
			var popupContainer = document.getElementById('user-popup-div');
			document.getElementById('popup_info').style.display = 'block';						
			
			// Modify coordinates so that arrow in popup points to selected username element
			popupContainer.style.left = (x - 35) + "px";
			popupContainer.style.top = (y + 25) + "px";
			popupContainer.style.display = 'block';
			
			// Add mousemove listener to detect when popup should be closed
			document.addEventListener('mousemove', this.mousemoveHandler);			
		},
		
		scrapeProfile: function(responseText) {
			var html = document.createElement('html');
			html.innerHTML = responseText;
			var tds = html.getElementsByTagName('td');
			// var status, aliases, rep;
			for (var i = 0, len = tds.length; i < len; i++) {
				var td = tds[i];
				if (td.innerText.indexOf('Status') > -1) {
					var status = tds[i + 1].innerText;
				}
				if (td.innerText.indexOf('Formerly') > -1) {
					var aliases = tds[i + 1].innerText;
				}
				if (td.innerText.indexOf('Reputation') > -1) {
					var rep = tds[i + 1].innerHTML;
				}
			}
			this.update(html, status, aliases, rep);
		},
		
		update: function(html, status, aliases, rep) {
			var placeholderElement = document.getElementById("popup_loading");			
			var aliasesElement = document.getElementById("namechange");
			var onlineElement = document.getElementById('online');
			var statusElement = document.getElementById('punish');
			var repElement = document.getElementById('rep');
			
			if (placeholderElement) {
				placeholderElement.style.display = 'none';
			}
			
			if (repElement) {
				repElement.innerHTML = rep;
			}
			
			if (allPages.config.show_old_name) {
				if (aliases) {
					aliasesElement.innerHTML = "<br>Formerly known as: <b>" + aliases + '</b>';
				}
			}	
			if (html.innerHTML.indexOf('(online now)') > -1) {
					onlineElement.innerHTML = '(online now)';
			}	
			if (status) {
				if (status.indexOf('Suspended') > -1) {
						statusElement.innerHTML = '<b>Suspended until: </b>' + status.substring(17);
				}
				if (status.indexOf('Banned') > -1) {
						statusElement.innerHTML = '<b>Banned</b>';
				}
			}		
		},
		
		checkAccountAge: function(userID) {
			// Returns appropriate "GS" value for account age. Otherwise, returns empty string
			if (!allPages.config.hide_gs) {
				switch (userID) {
					case (userID > 22682):
							return ' (gs)\u2076';
					case (userID > 21289):
							return ' (gs)\u2075';
					case (userID > 20176):
							return ' (gs)\u2074';
					case (userID > 15258):
							return ' (gs)\u00B3';
					case (userID > 13498):
							return ' (gs)\u00B2';
					case (userID > 10088):
							return ' (gs)';
					default:
							return '';
				}
			}
			else {				
				return '';
			}
		},
		
		hide: function() {
			document.getElementById('user-popup-div').style.display = 'none';			
			document.removeEventListener('mousemove', allPages.userInfoPopup.mousemoveHandler);
		},
		
		mousemoveHandler: function(evt) {			
			// Close popup if user moves mouse outside of popup (triggered after 250ms delay)
			if (!allPages.userInfoPopup.popupBoundaryCheck(evt.target)) {
				if (!allPages.userInfoPopup.waiting) {
					allPages.userInfoPopup.debouncerId = setTimeout(allPages.userInfoPopup.hide, 250);
					allPages.userInfoPopup.waiting = true;
				}
			}
			else {
				clearTimeout(allPages.userInfoPopup.debouncerId);
				allPages.userInfoPopup.waiting = false;
			}
		},
		
		/**
		 *  Returns true if we should continue to display popup after user moves mouse.
		 */
		 
		popupBoundaryCheck: function(target) {
			switch (target.className) {
				case 'user_info_popup':
				case 'username_anchor':
				case 'popup_link':
				case 'popup_user':
				case 'rep_anchor':
					return true;

				default:
					return false;
			}
		},
		
		clickHandler: function(evt) {
				var user = allPages.userInfoPopup.username.toLowerCase();				
				var functions;
				
				if (window.messageList) {
					var containers = document.getElementsByClassName('message-container');
					functions = messageList.messageContainerMethods;
				}
				
				else if (window.topicList) {	
					var trs = document.getElementsByTagName('tr');
					functions = topicList.functions;
				}
				
				var target = allPages.userInfoPopup.currentPost;
				var type = evt.target.innerHTML;
				
				switch (type) {			
					case "IGNORATE?":
						if (!allPages.config.ignorator_list || allPages.config.ignorator_list === '') {
							allPages.config.ignorator_list = allPages.userInfoPopup.username;
						} 
						else {
							allPages.config.ignorator_list += ", " + allPages.userInfoPopup.username;
						}
						
						browser.runtime.sendMessage({
							need : "save",
							name : "ignorator_list",
							data : allPages.config.ignorator_list
						});
						
						if (window.messageList) {
							messageList.config.ignorator_list = allPages.config.ignorator_list;
							messageList.prepareIgnoratorArray();
							for (var i = 0, len = containers.length; i < len; i++) {
								var container = containers[i];
								functions.ignorator_messagelist(container);
							}
						}
						
						else {
							topicList.config.ignorator_list = allPages.config.ignorator_list;
							topicList.createArrays();
							for (var i = 1, len = trs.length; i < len; i++) {
								var tr = trs[i];
								functions.ignorator_topiclist(tr, i);
							}
						}
						
						evt.target.innerHTML = "IGNORATE";
						allPages.userInfoPopup.hide();
						break;
						
					case "IGNORATE":
						evt.target.innerHTML = "IGNORATE?";
						break;
						
					case "PM":
						browser.runtime.sendMessage({
							need : "opentab",
							url : "http://endoftheinter.net/postmsg.php?puser=" + allPages.userInfoPopup.userId
						});
						allPages.userInfoPopup.hide();
						break;
						
					case "GT":
						browser.runtime.sendMessage({
							need : "opentab",
							url : "http://endoftheinter.net/token.php?type=2&user=" + allPages.userInfoPopup.userId
						});
						allPages.userInfoPopup.hide();
						break;
						
					case "BT":
						browser.runtime.sendMessage({
							need : "opentab",
							url : "http://endoftheinter.net/token.php?type=1&user=" + allPages.userInfoPopup.userId
						});
						allPages.userInfoPopup.hide();
						break;
						
					case "HIGHLIGHT":
						allPages.config.user_highlight_data[user] = {};
						allPages.config.user_highlight_data[user].bg = Math.floor(
								Math.random() * 16777215).toString(16);
						allPages.config.user_highlight_data[user].color = Math.floor(
								Math.random() * 16777215).toString(16);
						browser.runtime.sendMessage({
							need : "save",
							name : "user_highlight_data",
							data : allPages.config.user_highlight_data
						});
						if (window.messageList) {
							// update config object in messageList script
							messageList.config.user_highlight_data = allPages.config.user_highlight_data;
							var top;
							for (var i = 0, len = containers.length; i < len; i++) {
								container = containers[i];
								functions.userhl_messagelist(container, i);
								if (allPages.config.foxlinks_quotes) {
									 functions.foxlinks_quote(container);
								}
							}
						} else {
							// update config object in topicList script
							topicList.config.user_highlight_data = allPages.config.user_highlight_data;
							for (var i = 1, len = trs.length; i < len; i++) {
								tr = trs[i];
								functions.userhl_topiclist(tr);
							}
						}				
						break;
						
					case "UNHIGHLIGHT":
						delete allPages.config.user_highlight_data[allPages.userInfoPopup.username
								.toLowerCase()];
						browser.runtime.sendMessage({
							need : "save",
							name : "user_highlight_data",
							data : allPages.config.user_highlight_data
						});
						if (window.messageList) {
							// update config object in messageList scripts
							messageList.config.user_highlight_data = allPages.config.user_highlight_data;
							var message_tops = document.getElementsByClassName('message-top');
							for (var i = 0, len = message_tops.length; i < len; i++) {
								var top = message_tops[i];
								if (top.getElementsByTagName('a')[0]) {
									var userToCheck = top.getElementsByTagName('a')[0].innerHTML;
									if (userToCheck === allPages.userInfoPopup.username) {		
										top.style.background = '';
										top.style.color = '';
										var top_atags = top.getElementsByTagName('a');
										for ( var j = 0; j < top_atags.length; j++) {
											top_atags[j].style.color = '';
										}
									}
								}
							}
						} else {
							// update config object in topicList scripts
							topicList.config.user_highlight_data = allPages.config.user_highlight_data;
							var tds, td, tags;
							for (var i = 1, len = trs.length; i < len; i++) {
								tr = trs[i];
								tds = tr.getElementsByTagName('td');
								if (tds[1].getElementsByTagName('a')[0]) {
									var userToCheck = tds[1].getElementsByTagName('a')[0].innerHTML;
									if (userToCheck === allPages.userInfoPopup.username) {
										for (var j = 0, tds_len = tds.length; j < tds_len; j++) {
											td = tds[j];
											td.style.background = '';
											td.style.color = '';
											tags = td.getElementsByTagName('a');
											for (var k = 0, tags_len = tags.length; k < tags_len; k++) {
												tags[k].style.color = '';
											}
										}
									}
								}
							}
						}
						allPages.userInfoPopup.hide();
						break;
				}
		}
	},
	
	optionsMenu: {
		show: function() {
			var url = browser.extension.getURL('options.html');
			var div = document.createElement('div');
			var iframe = document.createElement('iframe');
			var width = window.innerWidth;
			var height = window.innerHeight;
			var close = document.createElement('div');
			var anchorHeight;
			
			div.id = "options_div";
			div.style.width = (width * 0.95) + 'px';
			div.style.height = (height * 0.95) + 'px';
			div.style.left = (width - (width * 0.975)) + 'px';
			div.style.top = (height - (height * 0.975)) + 'px';
			
			close.id = "close_options";

			iframe.style.width = "inherit";
			iframe.src = url;
			iframe.style.backgroundColor = "white";
			iframe.style.border = "none";
			
			document.getElementsByClassName('body')[0].style.opacity = 0.3;
			
			div.appendChild(close);
			div.appendChild(iframe);
			document.body.appendChild(div);
			
			anchorHeight = close.getBoundingClientRect().height * 2;
			iframe.style.height = ((height * 0.95) - anchorHeight) + 'px';
			
			this.addListeners();						
		},
		
		addListeners: function() {
			const ESCAPE_KEY = 27;
			
			document.body.addEventListener('click', this.hide);
			document.getElementById('close_options').addEventListener('click', this.hide);		
			document.body.addEventListener('keyup', (evt) => {
				if (evt.keyCode === ESCAPE_KEY) {
					this.hide();
				}			
			});
			
			document.body.addEventListener('mousewheel', this.preventScroll);
		},
		
		hide: function() {			
			var div = document.getElementById('options_div');
			var bodyClass = document.getElementsByClassName('body')[0];
			bodyClass.style.opacity = 1;
			document.body.removeChild(div);
			document.body.removeEventListener('click', allPages.optionsMenu.hide);						
			document.body.removeEventListener('keyup', allPages.optionsMenu.hide);
			document.body.removeEventListener('mousewheel', allPages.optionsMenu.preventScroll);
		},
		
		preventScroll: function(event) {
			event.preventDefault();
		}
	},
	
	
	/**
	 *  Queue of files to upload to ETI
	 */
	
	asyncUploadQueue: {
		queue: [],
		total: 0,
		index: 0,
		working: false,
		
		push: function(file) {
			this.total++;
			this.queue.push(file);			
		},
		
		next: function() {
			this.index++;
			this.working = true;			
			return this.queue.shift();
		},
		
		clear: function() {
			this.queue = [];
			this.total = 0;
			this.index = 0;
			this.working = false;
		},
		
		hasNext: function() {
			return (this.queue.length > 0);
		}
	},
	
	
	/**
	 *  Adds file to queue and handles UI update
	 */
	
	asyncUploadHandler: function(file, callback) {
		this.asyncUploadQueue.push(file);
		
		if (!this.asyncUploadQueue.working) {
			this.asyncUpload(this.asyncUploadQueue.next(), callback);
			
			browser.runtime.sendMessage({
					need: 'notify',								
					title: 'Uploading: (1/' + this.asyncUploadQueue.total + ')',
					message: ''
			});
		}			
	},
	
	
	/**
	 *  Uploads first item from asyncUploadQueue and is called recursively for any remaining files.
	 */
	
	asyncUpload: function(file, callback) {
		const UPLOAD_URL = 'https://u.endoftheinter.net/u.php';
		var xhr = new XMLHttpRequest();
		xhr.open('POST', UPLOAD_URL, true);
		xhr.withCredentials = "true";
		
		var formData = new FormData();
		formData.append('file', file);
		
		xhr.onload = () => {
			if (xhr.status === 200) {
				
				if (!this.asyncUploadQueue.hasNext()) {
					// No need to show progress anymore - change type to 'basic' and update title
					if (this.asyncUploadQueue.index > 1) {
						browser.runtime.sendMessage({
								need: 'notify',								
								title: 'Uploads complete',
								message: ''
						});
					}
					
					else {
						browser.runtime.sendMessage({
								need: 'notify',								
								title: 'Upload complete',
								message: ''
						});
					}
					
					this.asyncUploadQueue.clear();
				}
				
				else {
					// Start next upload
					this.asyncUpload(this.asyncUploadQueue.next(), callback);
					
					browser.runtime.sendMessage({
							need: 'notify',								
							title: 'Uploading: (' + this.asyncUploadQueue.index + '/' + this.asyncUploadQueue.total + ')',
							message: ''
					});					
				}
				
				this.handleAsyncUploadResponse(xhr.responseText, callback);
			}						
		};
				
		xhr.send(formData);
	},

	
	/**
	 *  Gets <img> code string from image upload response
	 */
	
	handleAsyncUploadResponse: function(responseText, callback) {
		var tmp = document.createElement('div');
		tmp.innerHTML = responseText;
		
		var tmp_input = tmp.getElementsByClassName('img')[0].getElementsByTagName('input')[0];
		
		if (tmp_input.value) {
			if (tmp_input.value.substring(0, 4) == '<img') {						
				callback(tmp_input.value);
			}
		}	
	},	
	
	/**
	 *  Method which copies ETI quoting behaviour when inserting text into textarea
	 */ 
	
	insertIntoTextarea: function(textToInsert) {
		var textarea = document.getElementById('message') || document.getElementsByTagName('textarea')[0];

		// If no other text has been added before sig belt, always insert text at beginning of textarea.
		// Fixes https://github.com/sonicmax/ChromeLL-2.0/issues/74
		var caret;
					
		// Check whether any text has been inserted before sig belt.
		// If user doesn't have a sig, it will always be inserted at caret position
		if (textarea.value) {
			var message = textarea.value.split('\n---')[0];
			if (message[0] === undefined) {
				// Insert at 0
				caret = 0;
			}								
		}
		
		if (caret !== 0) {
			// We can insert like message at caret position
			caret = textarea.selectionStart;
			// Match ETI behaviour for quotes by inserting two linebreaks
			textToInsert = '\n\n' + textToInsert;
		}			
		
		textarea.value = textarea.value.substring(0, caret) 
				+ textToInsert 
				+ textarea.value.substring(caret, textarea.value.length);						
		
		// Move caret to end of inserted text.
		var endOfInsertion = caret + textToInsert.length;
		
		// We have to call setSelectionRange from inside setTimeout because of weird Chrome bug
		setTimeout(() => {
			textarea.focus();
			textarea.setSelectionRange(endOfInsertion, endOfInsertion);
		}, 0);
	},
	
	callCommonFunctions: function() {
		for (var i in this.commonFunctions) {
			if (this.config[i]) {
				this.commonFunctions[i]();
			}
		}
		
		if (window.location.pathname === '/showmessages.php' || window.location.pathname === '/inboxthread.php') {
			addPopupCSS();
		}
	},
	
	init: function(config) {
		this.config = config;
		
		if (document.readyState == 'loading') {
			// wait for DOMContentLoaded to fire before attempting to modify DOM
			document.addEventListener('DOMContentLoaded', () => {
				this.callCommonFunctions();
			});
		}
		
		else {
			this.callCommonFunctions();
		}		
	}
};

var getCustomColors = function() {	
	// (first 'h1' element is either tag name (in topic list), or topic title (in message list)
	var titleText = document.getElementsByTagName('h1')[0];
	var anchor = document.getElementsByTagName('a')[0];
	var userbar = document.getElementsByClassName('userbar')[0];
	// Infobar is not displayed on reply threads, so use message instead
	var infobar = document.getElementsByClassName('infobar')[0] || document.getElementsByClassName('message')[0];
	var message = document.getElementsByClassName('message')[0] || document.getElementsByTagName('th')[0];			

	var customColors = {};
	customColors.text = window.getComputedStyle(titleText).getPropertyValue('color');			
	customColors.anchor = window.getComputedStyle(anchor).getPropertyValue('color');				
	customColors.body = window.getComputedStyle(document.body).getPropertyValue('background-color');
	customColors.message = window.getComputedStyle(message).getPropertyValue('background-color');
	customColors.userbar = window.getComputedStyle(userbar).getPropertyValue('background-color');
	customColors.infobar = window.getComputedStyle(infobar).getPropertyValue('background-color');
	
	// Kludgy fix to improve visiblity of user info popup if user is using custom CSS with rgba values.
	// Browser seems to just ignore the alpha parameter if we change rgba to rgb
	
	for (var color in customColors) {	
		if (customColors[color].indexOf('rgba') > -1) {
			customColors[color] = customColors[color].replace('rgba', 'rgb');
		}
	}
	
	return customColors;
};

var addPopupCSS = function() {
	var styleSheet = document.styleSheets[0];
	var customColors = getCustomColors();
	// Dynamically create rules for user info popup using ETI colour scheme (to make sure that content is readable)
	styleSheet.addRule('#user-popup-div',  'color: ' + customColors.text);			
	styleSheet.addRule('#user-popup-div',  'background: ' + customColors.message);
	styleSheet.addRule('#user-popup-div',  'border-color: ' + customColors.body);		
	styleSheet.addRule('.popup_link', 'color: ' + customColors.anchor);
	styleSheet.addRule('.popup_link', 'background: ' + customColors.userbar);
	styleSheet.addRule('#username, #popup_uid, #namechange, #online, #punish, #popup_loading, #rep, #rep a', 'color: ' + customColors.text);
	// #user-popup-div:before should be same colour as #user-popup-div background
	styleSheet.addRule('#user-popup-div:before', 'border-bottom-color: ' + customColors.body);	
	// #user-popup-div:after should be same colour as #user-popup-div border
	styleSheet.addRule('#user-popup-div:after', 'border-bottom-color: ' +   customColors.infobar);
};

browser.runtime.sendMessage({ need: "config" }).then(response => {
	
	allPages.init.call(allPages, response.data);
	
}, error => {
	console.log(error);
});

/*
 *  Dialog polyfill from https://github.com/GoogleChrome/dialog-polyfill
 */
 
(function() {

  // nb. This is for IE10 and lower _only_.
  var supportCustomEvent = window.CustomEvent;
  if (!supportCustomEvent || typeof supportCustomEvent === 'object') {
    supportCustomEvent = function CustomEvent(event, x) {
      x = x || {};
      var ev = document.createEvent('CustomEvent');
      ev.initCustomEvent(event, !!x.bubbles, !!x.cancelable, x.detail || null);
      return ev;
    };
    supportCustomEvent.prototype = window.Event.prototype;
  }

  /**
   * @param {Element} el to check for stacking context
   * @return {boolean} whether this el or its parents creates a stacking context
   */
  function createsStackingContext(el) {
    while (el && el !== document.body) {
      var s = window.getComputedStyle(el);
      var invalid = function(k, ok) {
        return !(s[k] === undefined || s[k] === ok);
      }
      if (s.opacity < 1 ||
          invalid('zIndex', 'auto') ||
          invalid('transform', 'none') ||
          invalid('mixBlendMode', 'normal') ||
          invalid('filter', 'none') ||
          invalid('perspective', 'none') ||
          s['isolation'] === 'isolate' ||
          s.position === 'fixed' ||
          s.webkitOverflowScrolling === 'touch') {
        return true;
      }
      el = el.parentElement;
    }
    return false;
  }

  /**
   * Finds the nearest <dialog> from the passed element.
   *
   * @param {Element} el to search from
   * @return {HTMLDialogElement} dialog found
   */
  function findNearestDialog(el) {
    while (el) {
      if (el.localName === 'dialog') {
        return /** @type {HTMLDialogElement} */ (el);
      }
      el = el.parentElement;
    }
    return null;
  }

  /**
   * Blur the specified element, as long as it's not the HTML body element.
   * This works around an IE9/10 bug - blurring the body causes Windows to
   * blur the whole application.
   *
   * @param {Element} el to blur
   */
  function safeBlur(el) {
    if (el && el.blur && el !== document.body) {
      el.blur();
    }
  }

  /**
   * @param {!NodeList} nodeList to search
   * @param {Node} node to find
   * @return {boolean} whether node is inside nodeList
   */
  function inNodeList(nodeList, node) {
    for (var i = 0; i < nodeList.length; ++i) {
      if (nodeList[i] === node) {
        return true;
      }
    }
    return false;
  }

  /**
   * @param {HTMLFormElement} el to check
   * @return {boolean} whether this form has method="dialog"
   */
  function isFormMethodDialog(el) {
    if (!el || !el.hasAttribute('method')) {
      return false;
    }
    return el.getAttribute('method').toLowerCase() === 'dialog';
  }

  /**
   * @param {!HTMLDialogElement} dialog to upgrade
   * @constructor
   */
  function dialogPolyfillInfo(dialog) {
    this.dialog_ = dialog;
    this.replacedStyleTop_ = false;
    this.openAsModal_ = false;

    // Set a11y role. Browsers that support dialog implicitly know this already.
    if (!dialog.hasAttribute('role')) {
      dialog.setAttribute('role', 'dialog');
    }

    dialog.show = this.show.bind(this);
    dialog.showModal = this.showModal.bind(this);
    dialog.close = this.close.bind(this);

    if (!('returnValue' in dialog)) {
      dialog.returnValue = '';
    }

    if ('MutationObserver' in window) {
      var mo = new MutationObserver(this.maybeHideModal.bind(this));
      mo.observe(dialog, {attributes: true, attributeFilter: ['open']});
    } else {
      // IE10 and below support. Note that DOMNodeRemoved etc fire _before_ removal. They also
      // seem to fire even if the element was removed as part of a parent removal. Use the removed
      // events to force downgrade (useful if removed/immediately added).
      var removed = false;
      var cb = function() {
        removed ? this.downgradeModal() : this.maybeHideModal();
        removed = false;
      }.bind(this);
      var timeout;
      var delayModel = function(ev) {
        if (ev.target !== dialog) { return; }  // not for a child element
        var cand = 'DOMNodeRemoved';
        removed |= (ev.type.substr(0, cand.length) === cand);
        window.clearTimeout(timeout);
        timeout = window.setTimeout(cb, 0);
      };
      ['DOMAttrModified', 'DOMNodeRemoved', 'DOMNodeRemovedFromDocument'].forEach(function(name) {
        dialog.addEventListener(name, delayModel);
      });
    }
    // Note that the DOM is observed inside DialogManager while any dialog
    // is being displayed as a modal, to catch modal removal from the DOM.

    Object.defineProperty(dialog, 'open', {
      set: this.setOpen.bind(this),
      get: dialog.hasAttribute.bind(dialog, 'open')
    });

    this.backdrop_ = document.createElement('div');
    this.backdrop_.className = 'backdrop';
    this.backdrop_.addEventListener('click', this.backdropClick_.bind(this));
  }

  dialogPolyfillInfo.prototype = {

    get dialog() {
      return this.dialog_;
    },

    /**
     * Maybe remove this dialog from the modal top layer. This is called when
     * a modal dialog may no longer be tenable, e.g., when the dialog is no
     * longer open or is no longer part of the DOM.
     */
    maybeHideModal: function() {
      if (this.dialog_.hasAttribute('open') && document.body.contains(this.dialog_)) { return; }
      this.downgradeModal();
    },

    /**
     * Remove this dialog from the modal top layer, leaving it as a non-modal.
     */
    downgradeModal: function() {
      if (!this.openAsModal_) { return; }
      this.openAsModal_ = false;
      this.dialog_.style.zIndex = '';

      // This won't match the native <dialog> exactly because if the user set top on a centered
      // polyfill dialog, that top gets thrown away when the dialog is closed. Not sure it's
      // possible to polyfill this perfectly.
      if (this.replacedStyleTop_) {
        this.dialog_.style.top = '';
        this.replacedStyleTop_ = false;
      }

      // Clear the backdrop and remove from the manager.
      this.backdrop_.parentNode && this.backdrop_.parentNode.removeChild(this.backdrop_);
      dialogPolyfill.dm.removeDialog(this);
    },

    /**
     * @param {boolean} value whether to open or close this dialog
     */
    setOpen: function(value) {
      if (value) {
        this.dialog_.hasAttribute('open') || this.dialog_.setAttribute('open', '');
      } else {
        this.dialog_.removeAttribute('open');
        this.maybeHideModal();  // nb. redundant with MutationObserver
      }
    },

    /**
     * Handles clicks on the fake .backdrop element, redirecting them as if
     * they were on the dialog itself.
     *
     * @param {!Event} e to redirect
     */
    backdropClick_: function(e) {
      if (!this.dialog_.hasAttribute('tabindex')) {
        // Clicking on the backdrop should move the implicit cursor, even if dialog cannot be
        // focused. Create a fake thing to focus on. If the backdrop was _before_ the dialog, this
        // would not be needed - clicks would move the implicit cursor there.
        var fake = document.createElement('div');
        this.dialog_.insertBefore(fake, this.dialog_.firstChild);
        fake.tabIndex = -1;
        fake.focus();
        this.dialog_.removeChild(fake);
      } else {
        this.dialog_.focus();
      }

      var redirectedEvent = document.createEvent('MouseEvents');
      redirectedEvent.initMouseEvent(e.type, e.bubbles, e.cancelable, window,
          e.detail, e.screenX, e.screenY, e.clientX, e.clientY, e.ctrlKey,
          e.altKey, e.shiftKey, e.metaKey, e.button, e.relatedTarget);
      this.dialog_.dispatchEvent(redirectedEvent);
      e.stopPropagation();
    },

    /**
     * Focuses on the first focusable element within the dialog. This will always blur the current
     * focus, even if nothing within the dialog is found.
     */
    focus_: function() {
      // Find element with `autofocus` attribute, or fall back to the first form/tabindex control.
      var target = this.dialog_.querySelector('[autofocus]:not([disabled])');
      if (!target && this.dialog_.tabIndex >= 0) {
        target = this.dialog_;
      }
      if (!target) {
        // Note that this is 'any focusable area'. This list is probably not exhaustive, but the
        // alternative involves stepping through and trying to focus everything.
        var opts = ['button', 'input', 'keygen', 'select', 'textarea'];
        var query = opts.map(function(el) {
          return el + ':not([disabled])';
        });
        // TODO(samthor): tabindex values that are not numeric are not focusable.
        query.push('[tabindex]:not([disabled]):not([tabindex=""])');  // tabindex != "", not disabled
        target = this.dialog_.querySelector(query.join(', '));
      }
      safeBlur(document.activeElement);
      target && target.focus();
    },

    /**
     * Sets the zIndex for the backdrop and dialog.
     *
     * @param {number} dialogZ
     * @param {number} backdropZ
     */
    updateZIndex: function(dialogZ, backdropZ) {
      if (dialogZ < backdropZ) {
        throw new Error('dialogZ should never be < backdropZ');
      }
      this.dialog_.style.zIndex = dialogZ;
      this.backdrop_.style.zIndex = backdropZ;
    },

    /**
     * Shows the dialog. If the dialog is already open, this does nothing.
     */
    show: function() {
      if (!this.dialog_.open) {
        this.setOpen(true);
        this.focus_();
      }
    },

    /**
     * Show this dialog modally.
     */
    showModal: function() {
      if (this.dialog_.hasAttribute('open')) {
        throw new Error('Failed to execute \'showModal\' on dialog: The element is already open, and therefore cannot be opened modally.');
      }
      if (!document.body.contains(this.dialog_)) {
        throw new Error('Failed to execute \'showModal\' on dialog: The element is not in a Document.');
      }
      if (!dialogPolyfill.dm.pushDialog(this)) {
        throw new Error('Failed to execute \'showModal\' on dialog: There are too many open modal dialogs.');
      }

      if (createsStackingContext(this.dialog_.parentElement)) {
        console.warn('A dialog is being shown inside a stacking context. ' +
            'This may cause it to be unusable. For more information, see this link: ' +
            'https://github.com/GoogleChrome/dialog-polyfill/#stacking-context');
      }

      this.setOpen(true);
      this.openAsModal_ = true;

      // Optionally center vertically, relative to the current viewport.
      if (dialogPolyfill.needsCentering(this.dialog_)) {
        dialogPolyfill.reposition(this.dialog_);
        this.replacedStyleTop_ = true;
      } else {
        this.replacedStyleTop_ = false;
      }

      // Insert backdrop.
      this.dialog_.parentNode.insertBefore(this.backdrop_, this.dialog_.nextSibling);

      // Focus on whatever inside the dialog.
      this.focus_();
    },

    /**
     * Closes this HTMLDialogElement. This is optional vs clearing the open
     * attribute, however this fires a 'close' event.
     *
     * @param {string=} opt_returnValue to use as the returnValue
     */
    close: function(opt_returnValue) {
      if (!this.dialog_.hasAttribute('open')) {
        throw new Error('Failed to execute \'close\' on dialog: The element does not have an \'open\' attribute, and therefore cannot be closed.');
      }
      this.setOpen(false);

      // Leave returnValue untouched in case it was set directly on the element
      if (opt_returnValue !== undefined) {
        this.dialog_.returnValue = opt_returnValue;
      }

      // Triggering "close" event for any attached listeners on the <dialog>.
      var closeEvent = new supportCustomEvent('close', {
        bubbles: false,
        cancelable: false
      });
      this.dialog_.dispatchEvent(closeEvent);
    }

  };

  var dialogPolyfill = {};

  dialogPolyfill.reposition = function(element) {
    var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
    var topValue = scrollTop + (window.innerHeight - element.offsetHeight) / 2;
    element.style.top = Math.max(scrollTop, topValue) + 'px';
  };

  dialogPolyfill.isInlinePositionSetByStylesheet = function(element) {
    for (var i = 0; i < document.styleSheets.length; ++i) {
      var styleSheet = document.styleSheets[i];
      var cssRules = null;
      // Some browsers throw on cssRules.
      try {
        cssRules = styleSheet.cssRules;
      } catch (e) {}
      if (!cssRules) { continue; }
      for (var j = 0; j < cssRules.length; ++j) {
        var rule = cssRules[j];
        var selectedNodes = null;
        // Ignore errors on invalid selector texts.
        try {
          selectedNodes = document.querySelectorAll(rule.selectorText);
        } catch(e) {}
        if (!selectedNodes || !inNodeList(selectedNodes, element)) {
          continue;
        }
        var cssTop = rule.style.getPropertyValue('top');
        var cssBottom = rule.style.getPropertyValue('bottom');
        if ((cssTop && cssTop !== 'auto') || (cssBottom && cssBottom !== 'auto')) {
          return true;
        }
      }
    }
    return false;
  };

  dialogPolyfill.needsCentering = function(dialog) {
    var computedStyle = window.getComputedStyle(dialog);
    if (computedStyle.position !== 'absolute') {
      return false;
    }

    // We must determine whether the top/bottom specified value is non-auto.  In
    // WebKit/Blink, checking computedStyle.top == 'auto' is sufficient, but
    // Firefox returns the used value. So we do this crazy thing instead: check
    // the inline style and then go through CSS rules.
    if ((dialog.style.top !== 'auto' && dialog.style.top !== '') ||
        (dialog.style.bottom !== 'auto' && dialog.style.bottom !== '')) {
      return false;
    }
    return !dialogPolyfill.isInlinePositionSetByStylesheet(dialog);
  };

  /**
   * @param {!Element} element to force upgrade
   */
  dialogPolyfill.forceRegisterDialog = function(element) {
    if (window.HTMLDialogElement || element.showModal) {
      console.warn('This browser already supports <dialog>, the polyfill ' +
          'may not work correctly', element);
    }
    if (element.localName !== 'dialog') {
      throw new Error('Failed to register dialog: The element is not a dialog.');
    }
    new dialogPolyfillInfo(/** @type {!HTMLDialogElement} */ (element));
  };

  /**
   * @param {!Element} element to upgrade, if necessary
   */
  dialogPolyfill.registerDialog = function(element) {
    if (!element.showModal) {
      dialogPolyfill.forceRegisterDialog(element);
    }
  };

  /**
   * @constructor
   */
  dialogPolyfill.DialogManager = function() {
    /** @type {!Array<!dialogPolyfillInfo>} */
    this.pendingDialogStack = [];

    var checkDOM = this.checkDOM_.bind(this);

    // The overlay is used to simulate how a modal dialog blocks the document.
    // The blocking dialog is positioned on top of the overlay, and the rest of
    // the dialogs on the pending dialog stack are positioned below it. In the
    // actual implementation, the modal dialog stacking is controlled by the
    // top layer, where z-index has no effect.
    this.overlay = document.createElement('div');
    this.overlay.className = '_dialog_overlay';
    this.overlay.addEventListener('click', function(e) {
      this.forwardTab_ = undefined;
      e.stopPropagation();
      checkDOM([]);  // sanity-check DOM
    }.bind(this));

    this.handleKey_ = this.handleKey_.bind(this);
    this.handleFocus_ = this.handleFocus_.bind(this);

    this.zIndexLow_ = 100000;
    this.zIndexHigh_ = 100000 + 150;

    this.forwardTab_ = undefined;

    if ('MutationObserver' in window) {
      this.mo_ = new MutationObserver(function(records) {
        var removed = [];
        records.forEach(function(rec) {
          for (var i = 0, c; c = rec.removedNodes[i]; ++i) {
            if (!(c instanceof Element)) {
              continue;
            } else if (c.localName === 'dialog') {
              removed.push(c);
            }
            removed = removed.concat(c.querySelectorAll('dialog'));
          }
        });
        removed.length && checkDOM(removed);
      });
    }
  };

  /**
   * Called on the first modal dialog being shown. Adds the overlay and related
   * handlers.
   */
  dialogPolyfill.DialogManager.prototype.blockDocument = function() {
    document.documentElement.addEventListener('focus', this.handleFocus_, true);
    document.addEventListener('keydown', this.handleKey_);
    this.mo_ && this.mo_.observe(document, {childList: true, subtree: true});
  };

  /**
   * Called on the first modal dialog being removed, i.e., when no more modal
   * dialogs are visible.
   */
  dialogPolyfill.DialogManager.prototype.unblockDocument = function() {
    document.documentElement.removeEventListener('focus', this.handleFocus_, true);
    document.removeEventListener('keydown', this.handleKey_);
    this.mo_ && this.mo_.disconnect();
  };

  /**
   * Updates the stacking of all known dialogs.
   */
  dialogPolyfill.DialogManager.prototype.updateStacking = function() {
    var zIndex = this.zIndexHigh_;

    for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {
      dpi.updateZIndex(--zIndex, --zIndex);
      if (i === 0) {
        this.overlay.style.zIndex = --zIndex;
      }
    }

    // Make the overlay a sibling of the dialog itself.
    var last = this.pendingDialogStack[0];
    if (last) {
      var p = last.dialog.parentNode || document.body;
      p.appendChild(this.overlay);
    } else if (this.overlay.parentNode) {
      this.overlay.parentNode.removeChild(this.overlay);
    }
  };

  /**
   * @param {Element} candidate to check if contained or is the top-most modal dialog
   * @return {boolean} whether candidate is contained in top dialog
   */
  dialogPolyfill.DialogManager.prototype.containedByTopDialog_ = function(candidate) {
    while (candidate = findNearestDialog(candidate)) {
      for (var i = 0, dpi; dpi = this.pendingDialogStack[i]; ++i) {
        if (dpi.dialog === candidate) {
          return i === 0;  // only valid if top-most
        }
      }
      candidate = candidate.parentElement;
    }
    return false;
  };

  dialogPolyfill.DialogManager.prototype.handleFocus_ = function(event) {
    if (this.containedByTopDialog_(event.target)) { return; }

    event.preventDefault();
    event.stopPropagation();
    safeBlur(/** @type {Element} */ (event.target));

    if (this.forwardTab_ === undefined) { return; }  // move focus only from a tab key

    var dpi = this.pendingDialogStack[0];
    var dialog = dpi.dialog;
    var position = dialog.compareDocumentPosition(event.target);
    if (position & Node.DOCUMENT_POSITION_PRECEDING) {
      if (this.forwardTab_) {  // forward
        dpi.focus_();
      } else {  // backwards
        document.documentElement.focus();
      }
    } else {
      // TODO: Focus after the dialog, is ignored.
    }

    return false;
  };

  dialogPolyfill.DialogManager.prototype.handleKey_ = function(event) {
    this.forwardTab_ = undefined;
    if (event.keyCode === 27) {
      event.preventDefault();
      event.stopPropagation();
      var cancelEvent = new supportCustomEvent('cancel', {
        bubbles: false,
        cancelable: true
      });
      var dpi = this.pendingDialogStack[0];
      if (dpi && dpi.dialog.dispatchEvent(cancelEvent)) {
        dpi.dialog.close();
      }
    } else if (event.keyCode === 9) {
      this.forwardTab_ = !event.shiftKey;
    }
  };

  /**
   * Finds and downgrades any known modal dialogs that are no longer displayed. Dialogs that are
   * removed and immediately readded don't stay modal, they become normal.
   *
   * @param {!Array<!HTMLDialogElement>} removed that have definitely been removed
   */
  dialogPolyfill.DialogManager.prototype.checkDOM_ = function(removed) {
    // This operates on a clone because it may cause it to change. Each change also calls
    // updateStacking, which only actually needs to happen once. But who removes many modal dialogs
    // at a time?!
    var clone = this.pendingDialogStack.slice();
    clone.forEach(function(dpi) {
      if (removed.indexOf(dpi.dialog) !== -1) {
        dpi.downgradeModal();
      } else {
        dpi.maybeHideModal();
      }
    });
  };

  /**
   * @param {!dialogPolyfillInfo} dpi
   * @return {boolean} whether the dialog was allowed
   */
  dialogPolyfill.DialogManager.prototype.pushDialog = function(dpi) {
    var allowed = (this.zIndexHigh_ - this.zIndexLow_) / 2 - 1;
    if (this.pendingDialogStack.length >= allowed) {
      return false;
    }
    if (this.pendingDialogStack.unshift(dpi) === 1) {
      this.blockDocument();
    }
    this.updateStacking();
    return true;
  };

  /**
   * @param {!dialogPolyfillInfo} dpi
   */
  dialogPolyfill.DialogManager.prototype.removeDialog = function(dpi) {
    var index = this.pendingDialogStack.indexOf(dpi);
    if (index === -1) { return; }

    this.pendingDialogStack.splice(index, 1);
    if (this.pendingDialogStack.length === 0) {
      this.unblockDocument();
    }
    this.updateStacking();
  };

  dialogPolyfill.dm = new dialogPolyfill.DialogManager();
  dialogPolyfill.formSubmitter = null;
  dialogPolyfill.useValue = null;

  /**
   * Installs global handlers, such as click listers and native method overrides. These are needed
   * even if a no dialog is registered, as they deal with <form method="dialog">.
   */
  if (window.HTMLDialogElement === undefined) {

    /**
     * If HTMLFormElement translates method="DIALOG" into 'get', then replace the descriptor with
     * one that returns the correct value.
     */
    var testForm = document.createElement('form');
    testForm.setAttribute('method', 'dialog');
    if (testForm.method !== 'dialog') {
      var methodDescriptor = Object.getOwnPropertyDescriptor(HTMLFormElement.prototype, 'method');
      if (methodDescriptor) {
        // nb. Some older iOS and older PhantomJS fail to return the descriptor. Don't do anything
        // and don't bother to update the element.
        var realGet = methodDescriptor.get;
        methodDescriptor.get = function() {
          if (isFormMethodDialog(this)) {
            return 'dialog';
          }
          return realGet.call(this);
        };
        var realSet = methodDescriptor.set;
        methodDescriptor.set = function(v) {
          if (typeof v === 'string' && v.toLowerCase() === 'dialog') {
            return this.setAttribute('method', v);
          }
          return realSet.call(this, v);
        };
        Object.defineProperty(HTMLFormElement.prototype, 'method', methodDescriptor);
      }
    }

    /**
     * Global 'click' handler, to capture the <input type="submit"> or <button> element which has
     * submitted a <form method="dialog">. Needed as Safari and others don't report this inside
     * document.activeElement.
     */
    document.addEventListener('click', function(ev) {
      dialogPolyfill.formSubmitter = null;
      dialogPolyfill.useValue = null;
      if (ev.defaultPrevented) { return; }  // e.g. a submit which prevents default submission

      var target = /** @type {Element} */ (ev.target);
      if (!target || !isFormMethodDialog(target.form)) { return; }

      var valid = (target.type === 'submit' && ['button', 'input'].indexOf(target.localName) > -1);
      if (!valid) {
        if (!(target.localName === 'input' && target.type === 'image')) { return; }
        // this is a <input type="image">, which can submit forms
        dialogPolyfill.useValue = ev.offsetX + ',' + ev.offsetY;
      }

      var dialog = findNearestDialog(target);
      if (!dialog) { return; }

      dialogPolyfill.formSubmitter = target;
    }, false);

    /**
     * Replace the native HTMLFormElement.submit() method, as it won't fire the
     * submit event and give us a chance to respond.
     */
    var nativeFormSubmit = HTMLFormElement.prototype.submit;
    function replacementFormSubmit() {
      if (!isFormMethodDialog(this)) {
        return nativeFormSubmit.call(this);
      }
      var dialog = findNearestDialog(this);
      dialog && dialog.close();
    }
    HTMLFormElement.prototype.submit = replacementFormSubmit;

    /**
     * Global form 'dialog' method handler. Closes a dialog correctly on submit
     * and possibly sets its return value.
     */
    document.addEventListener('submit', function(ev) {
      var form = /** @type {HTMLFormElement} */ (ev.target);
      if (!isFormMethodDialog(form)) { return; }
      ev.preventDefault();

      var dialog = findNearestDialog(form);
      if (!dialog) { return; }

      // Forms can only be submitted via .submit() or a click (?), but anyway: sanity-check that
      // the submitter is correct before using its value as .returnValue.
      var s = dialogPolyfill.formSubmitter;
      if (s && s.form === form) {
        dialog.close(dialogPolyfill.useValue || s.value);
      } else {
        dialog.close();
      }
      dialogPolyfill.formSubmitter = null;
    }, true);
  }

  dialogPolyfill['forceRegisterDialog'] = dialogPolyfill.forceRegisterDialog;
  dialogPolyfill['registerDialog'] = dialogPolyfill.registerDialog;

  if (typeof define === 'function' && 'amd' in define) {
    // AMD support
    define(function() { return dialogPolyfill; });
  } else if (typeof module === 'object' && typeof module['exports'] === 'object') {
    // CommonJS support
    module['exports'] = dialogPolyfill;
  } else {
    // all others
    window['dialogPolyfill'] = dialogPolyfill;
  }
})(); 